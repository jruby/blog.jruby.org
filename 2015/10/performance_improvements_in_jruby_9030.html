<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <title>
    
      The JRuby Blog : Performance Improvements in JRuby 9.0.3.0
    
  </title>

  <meta charset="utf-8" />
  <meta name="author" content="Shane Becker" />

  <link href="/feed" rel="alternate" title="No More Sharecropping" type="application/atom+xml" />
  <link rel="home" href="/" />

  <!--[if lt IE 9]> <script src="/javascripts/html5.js"></script> <![endif]-->
  <link rel="stylesheet" href="/stylesheets/syntax.css" />
<link rel="stylesheet" href="/stylesheets/asciidoc.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="/stylesheets/application.css" />

</head>

<body>
  <header role="banner">
    <a href="/" rel="home">
      <hgroup>
        <h1>The JRuby Blog</h1>
        <h2>The Ruby Programming Language on the JVM</h2>
      </hgroup>
    </a>
  </header>

  <article role="article" class="hentry">
  <header>
    <a href="/2015/10/performance_improvements_in_jruby_9030" rel="bookmark">
      <hgroup class="entry-title">
        <h1>Performance Improvements in JRuby 9.0.3.0</h1>
        
          <h2></h2>
        
      </hgroup>
    </a>

    <h3 class="vcard">
      Published <i>by</i> <a href="mailto:headius@headius.com" rel="email">Charles Oliver Nutter</a>
      <i>on</i> <time pubdate datetime="2015-10-21">October 21, 2015</time>
    </h3>
  </header>

  <section class="entry-content">
    <p>With the release of JRuby 9000, we promised you’d see our new runtime start to shine in update releases. Now, it’s starting to happen.</p>

<p><a href="http://jruby.org/2015/10/21/jruby-9-0-3-0.html">JRuby 9.0.3.0</a> has been released with three key performance improvements we’re very excited about.</p>

<h2 id="lightweight-postfix-rescues">Lightweight Postfix Rescues</h2>

<p>One of the most convenient anti-patterns in Ruby is the ability to add a <code class="language-plaintext highlighter-rouge">rescue</code> to any expression, capturing all StandardError descendants and instead returning another expression. You see this pattern a lot in code where any exception raised has a trivial fallback.</p>

<p>Unfortunately, exceptions can be very expensive on the JVM. For various reasons, when the JVM generates a stack trace, it has to do much more work than a runtime like CRuby: combining interpreted calls and compiled calls, breaking apart inlined code, omitting or reformatting internal calls. Generating a 1000-deep stack trace on the JVM can cost in the neighborhood of a few milliseconds.</p>

<p>This doesn’t sound like a lot until you start raising thousands of exceptions every second.</p>

<p>Here’s an example from csv.rb, Ruby’s standard library for CSV parsing.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="no">Converters</span>  <span class="o">=</span> <span class="p">{</span> <span class="ss">integer:   </span><span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span>
                    <span class="no">Integer</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="no">ConverterEncoding</span><span class="p">))</span> <span class="k">rescue</span> <span class="n">f</span>
                  <span class="p">},</span>
                  <span class="ss">float:     </span><span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span>
                    <span class="no">Float</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="no">ConverterEncoding</span><span class="p">))</span> <span class="k">rescue</span> <span class="n">f</span>
                  <span class="p">},</span>
<span class="o">...</span>
</code></pre></div></div>

<p>Ruby’s CSV library can automatically convert values to Ruby types as they are read. It does this by cascading attempts from one converter to the next using trivial rescues to capture any errors. Each converter executes in turn until one of them is able to convert the incoming data successfully.</p>

<p>Unfortunately, before 9.0.3.0, this had a tremendous impact on performance. Every exception raised here had to generate a very expensive stack trace…ultimately causing CSV value conversions to spend all their time in the guts of the JVM processing stack trace frames.</p>

<p>We received a <a href="https://github.com/jruby/jruby/issues/3348">bug report</a> showing JRuby processing and converting CSV almost 30x slower than CRuby, and we knew we had to do something.</p>

<p>Luckily, with our new runtime, it was easy for to make improvements. Credit goes to Tom Enebo for this <a href="https://github.com/jruby/jruby/issues/3348#issuecomment-145081388">excellent work</a>:</p>

<ul>
  <li>Inspect the expression provided for a rescue to see if it is trivial (local variable, constant value, etc).</li>
  <li>If trivial, entering the rescued code sets a thread-local flag indicating no stack trace will be needed.</li>
  <li>When raising exceptions, we can now omit stack traces we know will never be used.</li>
</ul>

<p>The result? Trivial rescues are now over <a href="https://github.com/jruby/jruby/commit/fb4dcb4ee17a2b6bff8f6c7be8a334cc8b1c6d78">40x faster than before</a> and JRuby handles CSV with conversions considerably faster than CRuby.</p>

<p>Note that this optimization only works when the lightweight rescue is directly upstream from the exception it captures. If there are intevening heavyweight rescues, we can’t optimize the stack trace away.</p>

<h2 id="independently-jitting-blocks">Independently Jitting Blocks</h2>

<p>You can see from the CSV code snippit above that the converters are held in a hash mapping symbols to lambda expressions. This was another case that needed fixing.</p>

<p>JRuby’s JIT has always occurred at method boundaries. If a method is called enough times, we compile it to JVM bytecode. However, there are libraries like CSV where the hot code is not contained within a method…it is a free-standing lambda or proc defined in a script or class body. Because of the limitations of our old JIT, this code would only run in the interpreter, which is generally many times slower than compiled JVM bytecode.</p>

<p>This is frequently compounded by the metaprogramming method <code class="language-plaintext highlighter-rouge">Module#define_method</code>, which allows you to define a new method using only a Ruby block. These definitions usually don’t occur within a method (or at least not within a method we JIT), so they too would never JIT.</p>

<p>In JRuby 9.0.3.0, I finally fixed this by modifying blocks to have their own independent call counters and JIT cycle. If a block is called enough times (currently the same 50-call threshold as methods), they will JIT into JVM bytecode even if the surrounding scope does not. We’ve promised this for years, but it wasn’t until our new runtime that we were able to make it possible.</p>

<p>This improvement makes formerly unjittable blocks anywhere from 5x to 20x faster than they were before.</p>

<p>And speaking of <code class="language-plaintext highlighter-rouge">define_method</code>…</p>

<h2 id="define_method-methods">define_method Methods</h2>

<p>For years we’ve wanted to be able to optimize <code class="language-plaintext highlighter-rouge">define_method</code> methods just like regular methods. The block JIT changes above certainly help that, but it is well known that blocks still have a more overhead (lexical context, heap-based local variables) than regular method bodies.</p>

<p>Once again our new runtime comes to the rescue. Thanks to additional work by Tom, JRuby 9.0.3.0 will now optimize non-capturing <code class="language-plaintext highlighter-rouge">define_method</code> methods (i.e. those that do not access variables from their lexical enclosure) as if they were normal methods. No extra context must be managed, no variables need to go on the heap, and all optimizations that apply to methods work just fine.</p>

<p>For cases where this optimization applies, you’ll see almost no difference in performance between a <code class="language-plaintext highlighter-rouge">define_method</code> method and one defined with the <code class="language-plaintext highlighter-rouge">def</code> keyword.</p>

<p>We don’t plan to stop here, either. For future releases, we plan to make capturing <code class="language-plaintext highlighter-rouge">define_method</code> methods also optimize like regular methods, modulo any context we can’t optimize away. Ideally, these methods should have only a small amount of overhead (or none at all) compared to their regular non-metaprogrammed siblings.</p>

<h2 id="more-to-come">More to Come</h2>

<p>We’re very happy with how JRuby 9000 has been received (our most stable, most compatible, and fastest JRuby ever) and we’ll continue to push the limits of what Ruby can do on the JVM (and what Ruby can do in general).</p>

<p>We’d love to hear what you’re doing with Ruby and JRuby and encourage you to <a href="http://jruby.org/community">join our community</a>!</p>



    <div id="disqus_thread"></div>
    <script>
      var disqus_shortname  = 'jruby';
      var disqus_identifier = '/2015/10/performance_improvements_in_jruby_9030';
      var disqus_title      = 'Performance Improvements in JRuby 9.0.3.0';

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </section>

  
</article>


  <footer role="contentinfo">
    <p>All post content is licensed under <a rel="license" href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons &mdash; Attribution 3.0 Unported">Creative Commons Attribution 3.0</a> unless stated otherwise by the author in that post.</p>
  </footer>

  <script>
    // google analytics
    var _gaq=[['_setAccount','UA-764576-26'],['_trackPageview']];
    (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
    g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
    s.parentNode.insertBefore(g,s)}(document,'script'));
  </script>
</body>
</html>
